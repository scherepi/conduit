//Helper functions to make cryptography less messy!

export async function generateKeyPair(): Promise<CryptoKeyPair> {
    return crypto.subtle.generateKey(
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        true,   // This needs to be set to true in order to be able to transmit the public key with the export function.
        ["deriveKey"]
    );
}
/**
 * Derives the shared symmetric key of an ECDH key exchange using the partner's public key transmitted.
 * @param publicKey - The public key passed by the cryptographic partner.
 * @param privateKey - The private key of the current client or server.
 * @returns - An X25519 symmetric key used for socket data encryption.
 */
export async function deriveSharedSecret(publicKey: CryptoKey, privateKey: CryptoKey): Promise<CryptoKey> {
    return crypto.subtle.deriveKey(
        {
            name: "X25519",
            public: publicKey
        },
        privateKey,
        {
            name: "AES-GCM",
            length: 256
        },
        false,
        ["encrypt", "decrypt"]
    )
}

/**
 * Takes a given message payload and fully converts it into a CryptoKey, the public key generated by the opposite party.
 */
export async function importKey(payload: Uint8Array<ArrayBufferLike>): Promise<CryptoKey> {
    return crypto.subtle.importKey("jwk",
        JSON.parse(new TextDecoder().decode(payload)),
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        true,
        ["deriveKey"]
    )
}
/**
 * Takes a given CryptoKey object and fully converts it into an encoded JWK string ready for transmission.
 * @param key The CryptoKey object to convert to a JWK string.
 */
export async function exportKey(key: CryptoKey): Promise<Uint8Array> {
    return new TextEncoder().encode(
        JSON.stringify(
            crypto.subtle.exportKey("jwk", key)
        )
    );
}

export async function encryptData(symKey: CryptoKey, message: Uint8Array): Promise<Uint8Array> {
    return new Uint8Array(await crypto.subtle.encrypt(
        {
            name: "RSA-OAEP" 
        },
        symKey,
        message
    ))
}

export async function decryptData(symKey: CryptoKey, message: Uint8Array) {
    return new Uint8Array(await crypto.subtle.decrypt(
        {
            name: "RSA-OAEP"
        },
        symKey,
        message
    ))
}