//Helper functions to make cryptography less messy!
/**
 * Generates an ECDH key-pair for the purposes of Diffie-Hellman key exchange.
 * @returns A CryptoKeyPair that can be transmitted and used to derive a symmetric key.
 */
export async function generateKeyPair(): Promise<CryptoKeyPair> {
    return crypto.subtle.generateKey(
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        true,   // This needs to be set to true in order to be able to transmit the public key with the export function.
        ["deriveKey"]
    );
}
/**
 * Derives the shared symmetric key of an ECDH key exchange using the partner's public key transmitted.
 * @param publicKey - The public key passed by the cryptographic partner.
 * @param privateKey - The private key of the current client or server.
 * @returns - An X25519 symmetric key used for socket data encryption.
 */
export async function deriveSharedSecret(publicKey: CryptoKey, privateKey: CryptoKey): Promise<CryptoKey> {
    return crypto.subtle.deriveKey(
        {
            name: "ECDH",
            public: publicKey
        },
        privateKey,
        {
            name: "AES-GCM",
            length: 256
        },
        false,
        ["encrypt", "decrypt"]
    )
}

/**
 * Takes a given message payload and fully converts it into a CryptoKey, the public key generated by the opposite party.
 * @param payload - The Uint8 array payload of the Javascript Web Key to be turned into a proper CryptoKey object.
 * @returns A CryptoKey object representing the transmitted key.
 */
export async function importKey(payload: Uint8Array): Promise<CryptoKey> {
    const decodedPayload = new TextDecoder().decode(payload);
    const parsedPayload = JSON.parse(decodedPayload);
    return crypto.subtle.importKey("jwk",
        parsedPayload,
        {
            name: "ECDH",
            namedCurve: "P-384"
        },
        true,
        []
    )
}
const IV_LENGTH = 12; // This is the initalization vector required for AES-GCM encryption. We elect to prepend it to the ciphertext here. I guess it's like salting?
/**
 * Takes a given CryptoKey object and fully converts it into an encoded JWK string ready for transmission.
 * @param key The CryptoKey object to convert to a JWK string.
 * @returns A Uint8Array of the CryptoKey as a JWK string.
 */
export async function exportKey(key: CryptoKey): Promise<Uint8Array> {
    const jwk = await crypto.subtle.exportKey("jwk", key);
    return new TextEncoder().encode(
        JSON.stringify(jwk)
    );
}

/**
 * Uses a shared symmetric key as previously derived from ECDH to encrypt a given Uint8 array.
 * @param symKey - The symmetric key for encryption.
 * @param message - The message (a Uint8Array) to be encrypted for transmission.
 * @returns An encrypted Uint8Array to be decrypted with the decryptData() function.
 */
export async function encryptData(symKey: CryptoKey, message: Uint8Array | null): Promise<Uint8Array> {
    console.log("Encrypting data using symmetric key");
    const plaintext = message == null ? new TextEncoder().encode("CONDUIT_SPECIAL_PAYLOAD_NULL") : message; // If the payload is supposed to be null, we will LITERALLY transmit NULL in all caps.
    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
    console.log("Generated iv " + iv);
    const ciphertext = await crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        symKey,
        plaintext
    );
    console.log("generated ciphertext " + new Uint8Array(ciphertext))
    // Add our IV to the beginning of the ciphertext before we send it.
    const result = new Uint8Array(iv.length + ciphertext.byteLength);
    result.set(iv, 0);
    result.set(new Uint8Array(ciphertext), iv.length);
    return result;
}

/**
 * Uses a shared symmetric key as previously derived from ECDH to decrypt a transmitted payload.
 * @param symKey - The symmetric key for encryption.
 * @param message - The message (a Uint8Array) to be decrypted.
 * @returns A decrypted Uint8Array.
 */
export async function decryptData(symKey: CryptoKey, message: Uint8Array) {
    const iv = message.slice(0, IV_LENGTH);
    const ciphertext = message.slice(IV_LENGTH);
    const plaintext = await crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        symKey,
        ciphertext
    );
    if (new TextDecoder().decode(plaintext) == "CONDUIT_SPECIAL_PAYLOAD_NULL") { return null; }
    return new Uint8Array(plaintext);
}